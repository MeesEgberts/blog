---
title: "Designing Scalable Systems with CQRS and Event Sourcing"
publishedAt: "2025-11-10"
summary: "Learn how CQRS and Event Sourcing help you design scalable, maintainable systems in NestJS by separating reads from writes and storing every change as an event."
slug: "event-sourcing"
---

## What is CQRS and Event Sourcing?

CQRS (Command Query Responsibility Segregation) is a pattern that separates the write side of your system—commands that change data—from the read side that queries data. This makes it easier to optimize and scale both parts independently.

Event Sourcing complements CQRS by storing every state change as an immutable event instead of overwriting data. The current state of an entity is rebuilt by replaying its events, creating a complete history of what happened.

## Why use CQRS and Event Sourcing?

Traditional CRUD systems mix reads and writes on the same models, which can become complex as applications grow. CQRS and Event Sourcing introduce a clearer separation of concerns, making it easier to evolve your domain logic, integrate other systems through events, and audit every change in your data.

## Benefits of CQRS and Event Sourcing?

* **Scalability:** Read and write sides scale independently.
* **Auditability:** Every change is recorded and traceable.
* **Flexibility:** Different models can serve optimized reads and consistent writes.
* **Debugging:** Replay events to reproduce past states or test new logic.
* **Integration:** Emit domain events that other services can subscribe to.

## Architecture Overview

In a CQRS and Event Sourcing setup, the system is divided into two sides:

* The **write side** handles *commands* that change state.
* The **read side** handles *queries* that retrieve state.

Commands go through a **Command Handler**, which applies logic on a **Domain Model** (or Aggregate). When something changes, the domain model emits **events** that are saved in the **Event Store**.

These events are then published through an **Event Bus** and processed by **Event Handlers**, which update the **Read Database** (a projection optimized for queries).

For simplicity, this example keeps the read and write sides within the same NestJS application, but in production they can be separate services communicating through an event bus.

<Image src="/diagrams/event-sourcing.png" className="w-full" alt="Event Sourcing Architecture" width={575}
       height={305}/>

### Implementing CQRS and Event Sourcing in NestJS

Start by creating a new NestJS project:

```bash
npm i -g @nestjs/cli
nest new event-sourcing
```

Next, install the official CQRS module, which provides the building blocks for commands, events, aggregates, and handlers:

```bash
npm install @nestjs/cqrs
```

Open your root module (`app.module.ts`) and import the `CqrsModule`. You can remove the default boilerplate to keep the project minimal:

```typescript
import { Module } from '@nestjs/common';
import { CqrsModule } from '@nestjs/cqrs';

@Module({
  imports: [CqrsModule],
})
export class AppModule {}
```

You can safely delete the default `app.controller.ts`, `app.service.ts`, and their corresponding spec file—these aren’t needed for this example.

At this point, your project is ready to define **aggregates**, **commands**, and **event handlers** following the CQRS and Event Sourcing architecture.

---

### Creating the Invoice Domain

For this example, we’ll build a simple *invoice management system* to demonstrate the flow of CQRS and Event Sourcing concepts.

Generate a new resource using the NestJS CLI:

```bash
nest g res invoices
```

When prompted:

* **What transport layer do you use?** REST API
* **Would you like to generate CRUD entry points?** Yes

We’ll organize the module using a clean architecture structure to separate responsibilities clearly:

```
src/
└── invoices/
    ├── application/      # Command & event handlers (use cases)
    ├── domain/           # Aggregates, entities, and events
    ├── infrastructure/   # Repositories, event store, persistence logic
    └── presentation/
        └── http/         # Controllers and DTOs
```

This layout keeps the CQRS flow clear: *commands* go through the application layer, *events* live in the domain layer, and *read models* or *APIs* are exposed through the presentation layer.

















---

You can explore the complete working example here: [NestJS Event Sourcing Starter](https://github.com/MeesEgberts/event-sourcing).
